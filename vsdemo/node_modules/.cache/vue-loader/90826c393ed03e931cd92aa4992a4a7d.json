{"remainingRequest":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/src/plugins/VirtualBlock/VirtualBlock.vue?vue&type=style&index=0&id=987c8a92&lang=scss&scoped=true&","dependencies":[{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/src/plugins/VirtualBlock/VirtualBlock.vue","mtime":1594690719000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/css-loader/index.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n.scroll-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n  .warpper {\r\n    height: 100%;\r\n  }\r\n  .loading {\r\n    display: flex;\r\n    flex-flow: row nowrap;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 60px;\r\n    color: #2d8cf0;\r\n  }\r\n}\r\n",{"version":3,"sources":["VirtualBlock.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"VirtualBlock.vue","sourceRoot":"src/plugins/VirtualBlock","sourcesContent":["<!-- 这个Demo根据用户传递过来的值，同时设置了向上和向下两个缓冲区，确保不管是向上滚动还是向下滚动都能确保非常顺畅的用户体验 -->\r\n<template>\r\n  <div class=\"scroll-container\" @scroll.passive=\"handleScroll\" ref=\"scrollContainer\">\r\n    <div class=\"warpper\" :style=\"paddingStyle\" ref=\"wapperBox\">\r\n      <div v-for=\"(item,index) in needReanderList\" :key=\"index\">\r\n        <slot :thisItem=\"item\"></slot>\r\n      </div>\r\n      <div class=\"loading\" v-if=\"onRequesting\">\r\n        <div>{{msg}}</div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {\r\n    //所有获取数据列表\r\n    allDataList: { default: () => [], type: Array },\r\n    //上下环缓存区数目\r\n    bufferSize: { default: () => 5, type: Number },\r\n    //单行显示高度\r\n    blockHeight: { default: () => 100, type: Number },\r\n    //是否正在请求批量数据状态\r\n    onRequesting: { default: () => true, type: Boolean },\r\n    //数据加载显示的区域\r\n    msg: { default: () => \"小二正在努力，请耐心等待...\", type: String }\r\n  },\r\n  data() {\r\n    return {\r\n      //屏幕容积数量\r\n      screenNum: 5,\r\n      //当前块所在的位置索引\r\n      currentBlockIndex: 0,\r\n      //记录当前行模块的偏移量\r\n      offsetBlock: 0,\r\n      //用来记录准确的当前block定位\r\n      rebackCurrentBlockIndex: 0\r\n    };\r\n  },\r\n  computed: {\r\n    //距离顶部位移\r\n    offsetTop() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return 0;\r\n      } else {\r\n        return (this.currentBlockIndex - this.bufferSize) * this.blockHeight;\r\n      }\r\n    },\r\n    //距离底部位移\r\n    offsetBottom() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return (\r\n          (this.allDataListLength - this.needRenderSize) * this.blockHeight\r\n        );\r\n      } else {\r\n        return (\r\n          (this.allDataListLength -\r\n            this.needRenderSize -\r\n            this.currentBlockIndex +\r\n            this.bufferSize) *\r\n          this.blockHeight\r\n        );\r\n      }\r\n    },\r\n    //根据上下位padding值，计算待渲染样式\r\n    paddingStyle() {\r\n      return {\r\n        \"padding-top\": this.offsetTop + \"px\",\r\n        \"padding-bottom\": this.offsetBottom + \"px\"\r\n      };\r\n    },\r\n    //根据屏幕容积数量和缓冲区数量，计算待渲染数据长度(这里要考虑上缓冲区在初始化的时候的需求)\r\n    needRenderSize() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return this.currentBlockIndex + this.screenNum + this.bufferSize;\r\n      } else {\r\n        return this.screenNum + this.bufferSize * 2;\r\n      }\r\n    },\r\n    //根据父组件传递的服务器拉取的数据，计算获取数据长度\r\n    allDataListLength() {\r\n      return this.allDataList.length;\r\n    },\r\n    //根据顶部位移以及缓冲区相关，计算带渲染数组的内容\r\n    needReanderList() {\r\n      let subArr = [];\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        subArr = this.allDataList.slice(0, this.needRenderSize);\r\n      } else {\r\n        subArr = this.allDataList.slice(\r\n          this.currentBlockIndex - this.bufferSize,\r\n          this.currentBlockIndex - this.bufferSize + this.needRenderSize\r\n        );\r\n      }\r\n      return [...subArr];\r\n    }\r\n  },\r\n  mounted() {\r\n    //监听屏幕变化，动态获取当前屏幕最大容积数量\r\n    this.myresize();\r\n    window.onresize = this.myresize;\r\n    window.orientationchange = this.myresize;\r\n  },\r\n  activated() {\r\n    //在keep-alive路由模式下，切换路由时确保能够返回用户之前所在位置\r\n    this.$nextTick(() => {\r\n      this.$refs.scrollContainer.scrollTop =\r\n        this.rebackCurrentBlockIndex * this.blockHeight + this.offsetBlock;\r\n    });\r\n  },\r\n  methods: {\r\n    //监听屏幕变化，动态获取屏幕最大容积数量，直接使用对应渲染API体验效果更佳\r\n    myresize() {\r\n      this.screenNum = ~~(window.innerHeight / this.blockHeight) + 2;\r\n      this.$refs.scrollContainer.style.height = window.innerHeight + \"px\";\r\n    },\r\n    //监听当前容器的滚动事件\r\n    handleScroll() {\r\n      //兼容低版本浏览器\r\n      window.requestAnimationFrame =\r\n        window.requestAnimationFrame ||\r\n        window.mozRequestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.msRequestAnimationFrame;\r\n      //浏览器防抖优化：根据浏览器FPS采用递归方法（常见游戏优化策略），队列调用requestAnimationFrame方法实现优化，同时兼容低浏览器版本\r\n      let fps = 30;\r\n      let now;\r\n      let then = Date.now();\r\n      let interval = 1000 / fps;\r\n      let that = this;\r\n      requestAnimationFrame(function() {\r\n        now = Date.now();\r\n        let delta = now - then;\r\n        then = now;\r\n        that.changeBufferneedReanderList();\r\n        if (delta >= interval) {\r\n          requestAnimationFrame(arguments.callee);\r\n        }\r\n      });\r\n    },\r\n    //根据滚动事件修正相应数据\r\n    changeBufferneedReanderList() {\r\n      //第一步，我们获取当前容器在scoll事件中距离顶部的位移\r\n      let scrollHeight = this.$refs.scrollContainer.scrollTop;\r\n      // 记录偏移量\r\n      this.offsetBlock = scrollHeight % this.blockHeight;\r\n      //第二步，根据当前位移，获取到当前需要渲染的数据起点位移所在位置，使用两次取反的方式计算对应的值\r\n      let currentBlockIndex = ~~(scrollHeight / this.blockHeight);\r\n      this.rebackCurrentBlockIndex = currentBlockIndex;\r\n      //第三步：如果我们发现当前的偏移量发生了变化，说明需要更新整个needReanderList对应的值了，这里要做一个判断，如果当前值没有发生变化则不进行渲染，防止资源消耗提高性能\r\n      if (this.currentBlockIndex == currentBlockIndex) return;\r\n      //第四步：判断是否到达底部，如果到达底部则触发新的数据请求\r\n      if (currentBlockIndex + this.screenNum >= this.allDataListLength) {\r\n        //如果用户滑动过快，因为截流函数100毫秒内，可能会导致很多值变化，offectBottom会因为计算属性而导致不合理变化，需要重新设置\r\n        this.$refs.wapperBox.style.paddingTop =\r\n          (this.allDataListLength - this.bufferSize) * this.blockHeight;\r\n        this.$refs.wapperBox.style.paddingBottom = \"0px\";\r\n        this.$emit(\"bottom\");\r\n      } else {\r\n        //第五步：如果没有到达底部，我们只需要在这里修正其新的index即可，剩下的交给计算属性来完成更详细的细节工作\r\n        this.currentBlockIndex = currentBlockIndex;\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.scroll-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n  .warpper {\r\n    height: 100%;\r\n  }\r\n  .loading {\r\n    display: flex;\r\n    flex-flow: row nowrap;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 60px;\r\n    color: #2d8cf0;\r\n  }\r\n}\r\n</style>\r\n"]}]}