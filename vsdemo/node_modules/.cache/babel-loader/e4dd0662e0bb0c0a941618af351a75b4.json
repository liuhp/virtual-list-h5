{"remainingRequest":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/babel-loader/lib/index.js!/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/src/plugins/VirtualBlock/VirtualBlock.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/src/plugins/VirtualBlock/VirtualBlock.vue","mtime":1594690719000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liuhaiping17/Downloads/document/projects/morse/虚拟列表/虚拟滚动体验源代码/vsdemo/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _toConsumableArray from \"/Users/liuhaiping17/Downloads/document/projects/morse/\\u865A\\u62DF\\u5217\\u8868/\\u865A\\u62DF\\u6EDA\\u52A8\\u4F53\\u9A8C\\u6E90\\u4EE3\\u7801/vsdemo/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport default {\n  props: {\n    //所有获取数据列表\n    allDataList: {\n      default: function _default() {\n        return [];\n      },\n      type: Array\n    },\n    //上下环缓存区数目\n    bufferSize: {\n      default: function _default() {\n        return 5;\n      },\n      type: Number\n    },\n    //单行显示高度\n    blockHeight: {\n      default: function _default() {\n        return 100;\n      },\n      type: Number\n    },\n    //是否正在请求批量数据状态\n    onRequesting: {\n      default: function _default() {\n        return true;\n      },\n      type: Boolean\n    },\n    //数据加载显示的区域\n    msg: {\n      default: function _default() {\n        return \"小二正在努力，请耐心等待...\";\n      },\n      type: String\n    }\n  },\n  data: function data() {\n    return {\n      //屏幕容积数量\n      screenNum: 5,\n      //当前块所在的位置索引\n      currentBlockIndex: 0,\n      //记录当前行模块的偏移量\n      offsetBlock: 0,\n      //用来记录准确的当前block定位\n      rebackCurrentBlockIndex: 0\n    };\n  },\n  computed: {\n    //距离顶部位移\n    offsetTop: function offsetTop() {\n      if (this.currentBlockIndex < this.bufferSize) {\n        return 0;\n      } else {\n        return (this.currentBlockIndex - this.bufferSize) * this.blockHeight;\n      }\n    },\n    //距离底部位移\n    offsetBottom: function offsetBottom() {\n      if (this.currentBlockIndex < this.bufferSize) {\n        return (this.allDataListLength - this.needRenderSize) * this.blockHeight;\n      } else {\n        return (this.allDataListLength - this.needRenderSize - this.currentBlockIndex + this.bufferSize) * this.blockHeight;\n      }\n    },\n    //根据上下位padding值，计算待渲染样式\n    paddingStyle: function paddingStyle() {\n      return {\n        \"padding-top\": this.offsetTop + \"px\",\n        \"padding-bottom\": this.offsetBottom + \"px\"\n      };\n    },\n    //根据屏幕容积数量和缓冲区数量，计算待渲染数据长度(这里要考虑上缓冲区在初始化的时候的需求)\n    needRenderSize: function needRenderSize() {\n      if (this.currentBlockIndex < this.bufferSize) {\n        return this.currentBlockIndex + this.screenNum + this.bufferSize;\n      } else {\n        return this.screenNum + this.bufferSize * 2;\n      }\n    },\n    //根据父组件传递的服务器拉取的数据，计算获取数据长度\n    allDataListLength: function allDataListLength() {\n      return this.allDataList.length;\n    },\n    //根据顶部位移以及缓冲区相关，计算带渲染数组的内容\n    needReanderList: function needReanderList() {\n      var subArr = [];\n\n      if (this.currentBlockIndex < this.bufferSize) {\n        subArr = this.allDataList.slice(0, this.needRenderSize);\n      } else {\n        subArr = this.allDataList.slice(this.currentBlockIndex - this.bufferSize, this.currentBlockIndex - this.bufferSize + this.needRenderSize);\n      }\n\n      return _toConsumableArray(subArr);\n    }\n  },\n  mounted: function mounted() {\n    //监听屏幕变化，动态获取当前屏幕最大容积数量\n    this.myresize();\n    window.onresize = this.myresize;\n    window.orientationchange = this.myresize;\n  },\n  activated: function activated() {\n    var _this = this;\n\n    //在keep-alive路由模式下，切换路由时确保能够返回用户之前所在位置\n    this.$nextTick(function () {\n      _this.$refs.scrollContainer.scrollTop = _this.rebackCurrentBlockIndex * _this.blockHeight + _this.offsetBlock;\n    });\n  },\n  methods: {\n    //监听屏幕变化，动态获取屏幕最大容积数量，直接使用对应渲染API体验效果更佳\n    myresize: function myresize() {\n      this.screenNum = ~~(window.innerHeight / this.blockHeight) + 2;\n      this.$refs.scrollContainer.style.height = window.innerHeight + \"px\";\n    },\n    //监听当前容器的滚动事件\n    handleScroll: function handleScroll() {\n      //兼容低版本浏览器\n      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; //浏览器防抖优化：根据浏览器FPS采用递归方法（常见游戏优化策略），队列调用requestAnimationFrame方法实现优化，同时兼容低浏览器版本\n\n      var fps = 30;\n      var now;\n      var then = Date.now();\n      var interval = 1000 / fps;\n      var that = this;\n      requestAnimationFrame(function () {\n        now = Date.now();\n        var delta = now - then;\n        then = now;\n        that.changeBufferneedReanderList();\n\n        if (delta >= interval) {\n          requestAnimationFrame(arguments.callee);\n        }\n      });\n    },\n    //根据滚动事件修正相应数据\n    changeBufferneedReanderList: function changeBufferneedReanderList() {\n      //第一步，我们获取当前容器在scoll事件中距离顶部的位移\n      var scrollHeight = this.$refs.scrollContainer.scrollTop; // 记录偏移量\n\n      this.offsetBlock = scrollHeight % this.blockHeight; //第二步，根据当前位移，获取到当前需要渲染的数据起点位移所在位置，使用两次取反的方式计算对应的值\n\n      var currentBlockIndex = ~~(scrollHeight / this.blockHeight);\n      this.rebackCurrentBlockIndex = currentBlockIndex; //第三步：如果我们发现当前的偏移量发生了变化，说明需要更新整个needReanderList对应的值了，这里要做一个判断，如果当前值没有发生变化则不进行渲染，防止资源消耗提高性能\n\n      if (this.currentBlockIndex == currentBlockIndex) return; //第四步：判断是否到达底部，如果到达底部则触发新的数据请求\n\n      if (currentBlockIndex + this.screenNum >= this.allDataListLength) {\n        //如果用户滑动过快，因为截流函数100毫秒内，可能会导致很多值变化，offectBottom会因为计算属性而导致不合理变化，需要重新设置\n        this.$refs.wapperBox.style.paddingTop = (this.allDataListLength - this.bufferSize) * this.blockHeight;\n        this.$refs.wapperBox.style.paddingBottom = \"0px\";\n        this.$emit(\"bottom\");\n      } else {\n        //第五步：如果没有到达底部，我们只需要在这里修正其新的index即可，剩下的交给计算属性来完成更详细的细节工作\n        this.currentBlockIndex = currentBlockIndex;\n      }\n    }\n  }\n};",{"version":3,"sources":["VirtualBlock.vue"],"names":[],"mappings":"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","sourcesContent":["<!-- 这个Demo根据用户传递过来的值，同时设置了向上和向下两个缓冲区，确保不管是向上滚动还是向下滚动都能确保非常顺畅的用户体验 -->\r\n<template>\r\n  <div class=\"scroll-container\" @scroll.passive=\"handleScroll\" ref=\"scrollContainer\">\r\n    <div class=\"warpper\" :style=\"paddingStyle\" ref=\"wapperBox\">\r\n      <div v-for=\"(item,index) in needReanderList\" :key=\"index\">\r\n        <slot :thisItem=\"item\"></slot>\r\n      </div>\r\n      <div class=\"loading\" v-if=\"onRequesting\">\r\n        <div>{{msg}}</div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {\r\n    //所有获取数据列表\r\n    allDataList: { default: () => [], type: Array },\r\n    //上下环缓存区数目\r\n    bufferSize: { default: () => 5, type: Number },\r\n    //单行显示高度\r\n    blockHeight: { default: () => 100, type: Number },\r\n    //是否正在请求批量数据状态\r\n    onRequesting: { default: () => true, type: Boolean },\r\n    //数据加载显示的区域\r\n    msg: { default: () => \"小二正在努力，请耐心等待...\", type: String }\r\n  },\r\n  data() {\r\n    return {\r\n      //屏幕容积数量\r\n      screenNum: 5,\r\n      //当前块所在的位置索引\r\n      currentBlockIndex: 0,\r\n      //记录当前行模块的偏移量\r\n      offsetBlock: 0,\r\n      //用来记录准确的当前block定位\r\n      rebackCurrentBlockIndex: 0\r\n    };\r\n  },\r\n  computed: {\r\n    //距离顶部位移\r\n    offsetTop() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return 0;\r\n      } else {\r\n        return (this.currentBlockIndex - this.bufferSize) * this.blockHeight;\r\n      }\r\n    },\r\n    //距离底部位移\r\n    offsetBottom() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return (\r\n          (this.allDataListLength - this.needRenderSize) * this.blockHeight\r\n        );\r\n      } else {\r\n        return (\r\n          (this.allDataListLength -\r\n            this.needRenderSize -\r\n            this.currentBlockIndex +\r\n            this.bufferSize) *\r\n          this.blockHeight\r\n        );\r\n      }\r\n    },\r\n    //根据上下位padding值，计算待渲染样式\r\n    paddingStyle() {\r\n      return {\r\n        \"padding-top\": this.offsetTop + \"px\",\r\n        \"padding-bottom\": this.offsetBottom + \"px\"\r\n      };\r\n    },\r\n    //根据屏幕容积数量和缓冲区数量，计算待渲染数据长度(这里要考虑上缓冲区在初始化的时候的需求)\r\n    needRenderSize() {\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        return this.currentBlockIndex + this.screenNum + this.bufferSize;\r\n      } else {\r\n        return this.screenNum + this.bufferSize * 2;\r\n      }\r\n    },\r\n    //根据父组件传递的服务器拉取的数据，计算获取数据长度\r\n    allDataListLength() {\r\n      return this.allDataList.length;\r\n    },\r\n    //根据顶部位移以及缓冲区相关，计算带渲染数组的内容\r\n    needReanderList() {\r\n      let subArr = [];\r\n      if (this.currentBlockIndex < this.bufferSize) {\r\n        subArr = this.allDataList.slice(0, this.needRenderSize);\r\n      } else {\r\n        subArr = this.allDataList.slice(\r\n          this.currentBlockIndex - this.bufferSize,\r\n          this.currentBlockIndex - this.bufferSize + this.needRenderSize\r\n        );\r\n      }\r\n      return [...subArr];\r\n    }\r\n  },\r\n  mounted() {\r\n    //监听屏幕变化，动态获取当前屏幕最大容积数量\r\n    this.myresize();\r\n    window.onresize = this.myresize;\r\n    window.orientationchange = this.myresize;\r\n  },\r\n  activated() {\r\n    //在keep-alive路由模式下，切换路由时确保能够返回用户之前所在位置\r\n    this.$nextTick(() => {\r\n      this.$refs.scrollContainer.scrollTop =\r\n        this.rebackCurrentBlockIndex * this.blockHeight + this.offsetBlock;\r\n    });\r\n  },\r\n  methods: {\r\n    //监听屏幕变化，动态获取屏幕最大容积数量，直接使用对应渲染API体验效果更佳\r\n    myresize() {\r\n      this.screenNum = ~~(window.innerHeight / this.blockHeight) + 2;\r\n      this.$refs.scrollContainer.style.height = window.innerHeight + \"px\";\r\n    },\r\n    //监听当前容器的滚动事件\r\n    handleScroll() {\r\n      //兼容低版本浏览器\r\n      window.requestAnimationFrame =\r\n        window.requestAnimationFrame ||\r\n        window.mozRequestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.msRequestAnimationFrame;\r\n      //浏览器防抖优化：根据浏览器FPS采用递归方法（常见游戏优化策略），队列调用requestAnimationFrame方法实现优化，同时兼容低浏览器版本\r\n      let fps = 30;\r\n      let now;\r\n      let then = Date.now();\r\n      let interval = 1000 / fps;\r\n      let that = this;\r\n      requestAnimationFrame(function() {\r\n        now = Date.now();\r\n        let delta = now - then;\r\n        then = now;\r\n        that.changeBufferneedReanderList();\r\n        if (delta >= interval) {\r\n          requestAnimationFrame(arguments.callee);\r\n        }\r\n      });\r\n    },\r\n    //根据滚动事件修正相应数据\r\n    changeBufferneedReanderList() {\r\n      //第一步，我们获取当前容器在scoll事件中距离顶部的位移\r\n      let scrollHeight = this.$refs.scrollContainer.scrollTop;\r\n      // 记录偏移量\r\n      this.offsetBlock = scrollHeight % this.blockHeight;\r\n      //第二步，根据当前位移，获取到当前需要渲染的数据起点位移所在位置，使用两次取反的方式计算对应的值\r\n      let currentBlockIndex = ~~(scrollHeight / this.blockHeight);\r\n      this.rebackCurrentBlockIndex = currentBlockIndex;\r\n      //第三步：如果我们发现当前的偏移量发生了变化，说明需要更新整个needReanderList对应的值了，这里要做一个判断，如果当前值没有发生变化则不进行渲染，防止资源消耗提高性能\r\n      if (this.currentBlockIndex == currentBlockIndex) return;\r\n      //第四步：判断是否到达底部，如果到达底部则触发新的数据请求\r\n      if (currentBlockIndex + this.screenNum >= this.allDataListLength) {\r\n        //如果用户滑动过快，因为截流函数100毫秒内，可能会导致很多值变化，offectBottom会因为计算属性而导致不合理变化，需要重新设置\r\n        this.$refs.wapperBox.style.paddingTop =\r\n          (this.allDataListLength - this.bufferSize) * this.blockHeight;\r\n        this.$refs.wapperBox.style.paddingBottom = \"0px\";\r\n        this.$emit(\"bottom\");\r\n      } else {\r\n        //第五步：如果没有到达底部，我们只需要在这里修正其新的index即可，剩下的交给计算属性来完成更详细的细节工作\r\n        this.currentBlockIndex = currentBlockIndex;\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.scroll-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n  .warpper {\r\n    height: 100%;\r\n  }\r\n  .loading {\r\n    display: flex;\r\n    flex-flow: row nowrap;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 60px;\r\n    color: #2d8cf0;\r\n  }\r\n}\r\n</style>\r\n"],"sourceRoot":"src/plugins/VirtualBlock"}]}